## MySQL数据类型

### 整数类型
TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT

UNSIGNED: 非负数

长度：可以为整数类型指定宽度，例如：INT(11)，对大多数应用是没有意义的，它不会限制值的合法范围，自会影响显示字符的个数

### 实数类型

FLOAT, DOUBLE, DECIMAL

DECIMAL可以存储比BIGINT还大的整数，可以用于存储精确的小数，可以理解为是将数字以字符串的形式存储

FLOAT和DOUBLE类型支持使用 *标准的浮点* 进行近似计算,对于计算来说FLOAT和DOUBLE效率更高

### 字符串类型

VARCHAR, CHAR, TEXT, BLOB

VARCHAR用于存储可变长字符串，它比定长类型更节省空间，使用1-2个额外字节记录字符串的长度，列长度小于255时，使用1个字节，否则用2个

如果存储的内容超出指定长度，会被截断，有的版本还会报错

CHAR是定长的，根据定义的字符串长度分配足够的空间，会根据需要采用空格进行填充以方便比较

适合存储很短的字符串，或者所有值都接近同一个长度
超出指定长度时，会被截断

区别：对于经常变更的数据，char比varchar更好，char不容易产生碎片，对于非常短的列，char比varchar在存储空间上更有效率，只分配真正的空间，更长的列会消耗更多的内存


BLOL/TEXT
查询会使用临时表，极大影响性能


### 枚举

可以使用枚举代替常用的字符串类型，把不重复的集合存储成一个预定义的集合，非常紧凑，把列表值压缩到一两个字节，内部存储的是整数，尽量避免使用数字作为枚举的常量，排序是按照内部存储的整数进行排序的

### 日期和时间

尽量使用TIMESTAMP，比DATETIME空间效率高，用整数保存时间戳的格式通常不方便处理，如果需要存储微秒，可以使用bigint存储


## MySQL基础操作
连接和关闭：mysql -u -p -h -P

其他：\G, \c, \q, \s, \h, \d

## MySQL数据表引擎

### INNODB
默认事务型引擎，是最重要最广泛的存储引擎，性能非常优秀，数据存储在共享表空间（表的索引和数据都在一个文件里保存），可以通过配置分开

对主键查询的性能高于其他类型的存储引擎

内部做了许多优化，从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区

通过一些机制和工具支持真正的热备份

支持奔溃后的安全恢复

支持行级锁，外键

### MYISAM

5.1 版本前是默认的存储引擎

拥有全文索引，压缩，空间函数

不支持事务和行级锁，不支持奔溃后的安全恢复

表存储在两个文件，MYD, MYI

设计简单，某些场景下性能很好，比如 `select count(*) from xxx`

### 其他
Archive, Blackhole, CSV, Memory

优先选择Innodb

## MySQL锁机制

当多个查询同一时刻进行数据修改时，就会产生并发控制的问题

### 共享锁（读锁）
是共享的，多个用户都可以读取，不堵塞互不干扰


### 排他锁（写锁）
排他的，一个写锁会阻塞其他的写锁和读锁，防止其他用户读取正在写入的内容


### 锁粒度
表锁，系统性能开销最小，会锁定整张表
行锁，最大程度支持并发处理，带来了最大的锁开销


## 事务处理

MySQL提供事务处理的表引擎，innodb
服务器层不管理事务，由下层引擎实现，所以同一个事务中，使用多种存储引擎不靠谱
在非事务的表引擎上做事务操作，不会报错，但不生效

## 存储过程

为以后使用而保存的一条或多条MySQL语句的集合，存储过程有业务逻辑和流程的集合
可以在存储过程中创建表，更新数据，删除等等

### 使用场景
通过把数据封装在容易使用的单元中，简化复杂操作
保证数据一致性，简化对变动的管理


## 触发器
保证数据完整性的一种方法，是与表事件相关的特殊的存储过程

### 使用场景

通过数据库中的相关表实现级联更改

实时监控某张表中的某个字段更改而需要作出相应的处理

滥用会造成不好管理





