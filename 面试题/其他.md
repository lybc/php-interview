
## Ngxin 和 Apache 的区别？

### Nginx
1. 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源

2. 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。

3. nginx 处理静态文件好，静态处理性能比 apache 高三倍以上

4. nginx 的设计高度模块化，编写模块相对简单

5. nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃

6. nginx 作为负载均衡服务器，支持 7 层负载均衡

7. nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器

8. 启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级

9. 社区活跃，各种高性能模块出品迅速

### Apache

1. apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache

2. apache 发展到现在，模块超多，基本想到的都可以找到

3. apache 更为成熟，少 bug ，nginx 的 bug 相对较多

4. apache 超稳定

5. apache 对 PHP 支持比较简单，nginx 需要配合其他后端用

6. apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。

7. apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区

两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。

更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。

## Redis 的底层数据结构有哪些？

## 定时任务管理如何实现？

## 如何排查 403 和 404 错误？

## 如何配置Redis集群

Redis 集群采用了P2P的模式，完全去中心化。Redis 把所有的 Key 分成了 16384 个 slot，每个 Redis 实例负责其中一部分 slot 。集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。
Redis 客户端可以在任意一个 Redis 实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。

```
cluster-enabled yes（启动集群模式）
cluster-config-file nodes9001.conf（9001和port要对应）
cluster-node-timeout 15000
```

## 网络编程中阻塞式和非阻塞式的特点，如何使用非阻塞编程实现HTTP代理服务器

同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。


异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。


阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。

非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

## Redis如何限制每个IP每小时只能访问5次


## 用正则表达式描述所有是4的倍数的二进制


## Redis持久化的方式

1. 快照 （RDB文件），在一个特定间隔保存那个时间点的一个数据快照

dbfilename dump.rdb
   
2. 追加 （AOF），记录每一个服务器收到的写操作，在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据

配置项 appendonly = yes